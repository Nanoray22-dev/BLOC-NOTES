import { r as resolveHTTPResponse } from '../../resolveHTTPResponse-4e576698.mjs';
import '../../config-65c5b6d1.mjs';
import '../../TRPCError-2b10c8d2.mjs';
import '../../index-044a193b.mjs';
import '../../codes-24aa1ce1.mjs';
import '../../transformTRPCResponse-3dca0b20.mjs';
import '../../contentType-acc3be52.mjs';

async function fetchRequestHandler(opts) {
    const resHeaders = new Headers();
    const createContext = async ()=>{
        return opts.createContext?.({
            req: opts.req,
            resHeaders
        });
    };
    const url = new URL(opts.req.url);
    const path = url.pathname.slice(opts.endpoint.length + 1);
    const req = {
        query: url.searchParams,
        method: opts.req.method,
        headers: Object.fromEntries(opts.req.headers),
        body: opts.req.headers.get('content-type') === 'application/json' ? await opts.req.text() : ''
    };
    const result = await resolveHTTPResponse({
        req,
        createContext,
        path,
        router: opts.router,
        batching: opts.batching,
        responseMeta: opts.responseMeta,
        onError (o) {
            opts?.onError?.({
                ...o,
                req: opts.req
            });
        }
    });
    for (const [key, value] of Object.entries(result.headers ?? {})){
        /* istanbul ignore if -- @preserve */ if (typeof value === 'undefined') {
            continue;
        }
        if (typeof value === 'string') {
            resHeaders.set(key, value);
            continue;
        }
        for (const v of value){
            resHeaders.append(key, v);
        }
    }
    const res = new Response(result.body, {
        status: result.status,
        headers: resHeaders
    });
    return res;
}

export { fetchRequestHandler };
